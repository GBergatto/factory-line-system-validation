sort Belt = struct input | reset | upgrade;
	Mode = struct normal | emergency;



act itemOk, itemDefectT, itemDefectR;

proc Judge =
    tau . itemOk . Judge +
    tau . (
        itemDefectT . Judge +
        itemDefectR . Judge
    );



act alarm, unalarm, safeOutput, safeTrash, safeReset;
    safeBeltStart, safeBeltStop, safeBeltYield, safeBeltDeliver, unsafeBeltStop: Belt;

proc EmergencyHandler(m: Mode) =
	((m == normal) -> alarm . EmergencyHandler(emergency)) +
	((m == normal) -> safeOutput . EmergencyHandler(m)) +
	((m == normal) -> safeTrash . EmergencyHandler(m)) +
	((m == normal) -> safeReset . EmergencyHandler(m)) +
	sum b:Belt . ((m == normal) -> safeBeltStart(b) . EmergencyHandler(m)) +
	sum b:Belt . ((m == normal) -> safeBeltStop(b) . EmergencyHandler(m)) +
	sum b:Belt . ((m == normal) -> safeBeltYield(b) . EmergencyHandler(m)) +
	sum b:Belt . ((m == normal) -> safeBeltDeliver(b) . EmergencyHandler(m)) +
	((m == emergency) -> unalarm . EmergencyHandler(normal)) +
	sum b:Belt . ((m == emergency) -> unsafeBeltStop(b) . EmergencyHandler(m));



act deliverItem, pickFrom: Belt;

proc Arm(isHoldingItem: Bool) =
	(isHoldingItem)
		-> deliverItem(upgrade) . Arm(false)
		<> (pickFrom(input) + pickFrom(reset)) . Arm(true);
		% WARNING: this won't satisfy the requirements of always taking from reset if possible



act yieldToCheckO, yieldToCheckT, yieldToCheckR;
    start, stop, emergencyStop, receiveItem, yield, itemDetected: Belt;

proc ConveyorBelt(b: Belt, isMoving: Bool, hasItem: Bool, itemAtEnd: Bool) =
	% Try to allow `alarm` between detect and stop?
	% Try to remove these bounds and see what this does with the number of states.
	((!isMoving             && !itemAtEnd                ) -> start(b)         . ConveyorBelt(b, true,     hasItem, itemAtEnd)) +
	(( isMoving                                          ) -> stop(b)          . ConveyorBelt(b, false,    hasItem, itemAtEnd)) +
	(( isMoving                                          ) -> emergencyStop(b) . ConveyorBelt(b, false,    hasItem, itemAtEnd)) +
	((!isMoving && !hasItem                              ) -> receiveItem(b)   . ConveyorBelt(b, isMoving, true   , itemAtEnd)) +
	((!isMoving             &&  itemAtEnd && b == upgrade) -> yieldToCheckO    . ConveyorBelt(b, isMoving, false  , false    )) +
	((!isMoving             &&  itemAtEnd && b == upgrade) -> yieldToCheckT    . ConveyorBelt(b, isMoving, false  , false    )) +
	((!isMoving             &&  itemAtEnd && b == upgrade) -> yieldToCheckR    . ConveyorBelt(b, isMoving, false  , false    )) +
	((!isMoving             &&  itemAtEnd && b != upgrade) -> yield(b)         . ConveyorBelt(b, isMoving, false  , false    )) +
	(( isMoving &&  hasItem && !itemAtEnd                ) -> itemDetected(b)  . ConveyorBelt(b, isMoving, hasItem, true     ));



act acceptItem, trashItem, resetItem;

proc Checker(n: Nat) =
	acceptItem . Checker(0) +
	(n >= 100)
		-> (trashItem . Checker(0))
		<> (resetItem . deliverItem(reset) . Checker(n + 1));



act moveToOutput, moveToTrash, moveToReset;
act startBelt, stopBelt, emergencyStopBelt, pickItem, placeItem: Belt;

init
	allow(
		{startBelt, stopBelt, emergencyStopBelt, pickItem, placeItem, moveToOutput, moveToTrash, moveToReset, alarm, unalarm, itemDetected},
		comm(
			{
				safeBeltStart | start -> startBelt,
				safeBeltStop | stop -> stopBelt,
				unsafeBeltStop | emergencyStop -> emergencyStopBelt,
				safeBeltYield | yield | pickFrom -> pickItem,
				safeBeltDeliver | deliverItem | receiveItem -> placeItem,

				safeOutput | yieldToCheckO | itemOk | acceptItem -> moveToOutput,
				safeTrash | yieldToCheckT | itemDefectT | trashItem -> moveToTrash,
				safeReset | yieldToCheckR | itemDefectR | resetItem -> moveToReset
			},
			ConveyorBelt(input, true, true, false) ||
			ConveyorBelt(reset, false, false, false) ||
			ConveyorBelt(upgrade, false, false, false) ||
			Arm(false) ||
			Checker(0) ||
			EmergencyHandler(normal)
		)
	);