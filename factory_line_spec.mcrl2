sort Belt = struct input | reset | upgrade;
	Mode = struct normal | emergency;

act start, stop, itemDetected: Belt;
	itemOk, itemDefect, moveToOutput, moveToTrash,
	alarm, unalarm;
act put, take, toBelt, fromBelt: Belt;

proc Arm(m: Mode, isHoldingItem: Bool) = 
	unalarm . Arm(normal, isHoldingItem) +
	alarm . Arm(emergency, isHoldingItem) +
	(m == normal)
		-> (isHoldingItem)
			-> put(upgrade) . Arm(m, false)
			<> (take(input) + take(reset)) . Arm(m, true);
			% WARNING: this won't satisfy the requirements of always taking from reset if possible

proc ConveyorBelt(m: Mode, b: Belt, isMoving: Bool, interrupted: Bool) =
	% Try to allow `alarm` between detect and stop?
	% Try to remove these bounds and see what this does with the number of states.
	(isMoving) -> itemDetected(b) . stop(b) . ConveyorBelt(normal, b, false, false) +
	(!isMoving) -> start(b) . ConveyorBelt(normal, b, true, false) +
	(m == normal && interrupted) -> (
		start(b) . ConveyorBelt(normal, b, true, false) +
		alarm . (isMoving)
			-> stop(b) . ConveyorBelt(emergency, b, false, true)
			<> ConveyorBelt(emergency, b, false, false)
	) +
	(m == emergency) -> (
		unalarm . (interrupted) -> start(b) . ConveyorBelt(normal, b, true, false)
	);

proc Checker(m: Mode, n: Nat) =
	(m == emergency) -> unalarm . Checker(normal, n) +
	(m == normal) -> (
		alarm . Checker(emergency, n) +
		take(upgrade) . itemOk . moveToOutput . Checker(normal, 0) + % itemOk/Defect should come from outside? => use comm{take | itemOk -> _ } but then take will be synchronized in different ways
		take(upgrade) . itemDefect . (n >= 10)
			-> (moveToTrash . Checker(normal, 0))
			<> (put(reset) . Checker(normal, n + 1))
	);

init
	allow(
		{toBelt, fromBelt, alarm, unalarm, itemOk, itemDefect, itemDetected, moveToOutput, moveToTrash},
		comm(
			{
				put | start -> toBelt,
				stop | take -> fromBelt
			},
			ConveyorBelt(normal, input, true, false) ||
			ConveyorBelt(normal, reset, false, false) ||
			ConveyorBelt(normal, upgrade, false, false) ||
			Arm(normal, false) || Checker(normal, 0)
		)
	);