sort Location = struct inputL | resetL;
	Belt = struct input | reset | upgrade;
	Mode = struct normal | emergency;

act start, stop, itemDetected: Belt;
	pickItem: Location;
	placeItem: Belt;
	itemOk, itemDefect, moveToOutput, moveToReset, moveToTrash,
	alarm, unalarm;
act provideInput: Belt; provideOutput, provideTrash;
act inputItem:Belt; upgradeItem: Belt; acceptItem, reworkItem, rejectItem, trashItem, outputItem, resetItem;

proc Arm(m: Mode, isHoldingItem: Bool) = 
	unalarm . Arm(normal, isHoldingItem) +
	alarm . Arm(emergency, isHoldingItem) +
	(m == normal)
		-> (isHoldingItem)
			-> placeItem(upgrade) . Arm(m, false)
			<> sum l:Location. pickItem(l) . Arm(m, true);

% start input conveyor
proc ConveyorBelt(m: Mode, b: Belt, isMoving: Bool, interrupted: Bool) =
	% Try to allow `alarm` between detect and stop?
	% Try to remove these bounds and see what this does with the number of states.
	(isMoving) -> itemDetected(b) . stop(b) . ConveyorBelt(normal, b, false, false) +
	(!isMoving) -> start(b) . ConveyorBelt(normal, b, true, false) +
	(m == normal && interrupted) -> (
		start(b) . ConveyorBelt(normal, b, true, false) +
		alarm . (isMoving)
			-> stop(b) . ConveyorBelt(emergency, b, false, true)
			<> ConveyorBelt(emergency, b, false, false)
	) +
	(m == emergency) -> (
		unalarm . (interrupted) -> start(b) . ConveyorBelt(normal, b, true, false)
	);

proc Checker(m: Mode, n: Nat) =
	(m == emergency) -> unalarm . Checker(normal, n) +
	(m == normal) -> (
		alarm . Checker(emergency, n) +
		itemOk . moveToOutput . Checker(normal, 0) +
		(n == 10)											% N = 10, requirement requires equality, so ==.
			-> (rejectItem . Checker(normal, 0))
			<> (reworkItem . Checker(normal, n + 1))
	);
			

init
	allow(
		{inputItem, upgradeItem, acceptItem, rejectItem, reworkItem, outputItem, trashItem, resetItem},
		comm(
			{
				% instead of adding provide intput, we could have the first conveyor running in init
				% and eventually a itemDetected will take place??
				provideInput | start -> inputItem,
				placeItem | start -> upgradeItem,

				itemOk | moveToOutput -> acceptItem,
				itemDefect | moveToTrash -> rejectItem,
				itemDefect | moveToReset -> reworkItem,

				acceptItem | provideOutput -> outputItem,
				rejectItem | provideTrash -> trashItem,
				reworkItem | start -> resetItem
			},

			ConveyorBelt(normal, input, false, false) ||
			ConveyorBelt(normal, reset, false, false) ||
			ConveyorBelt(normal, upgrade, false, false) ||
			Arm(normal, false) || Checker(normal, 0)
		)
	);